import { connect, createConfig, getAccount, getBalance, getConnections, getEnsAvatar, getEnsName, injected, prepareTransactionRequest, reconnect, signMessage, switchChain, disconnect as wagmiDisconnect, estimateGas as wagmiEstimateGas, getEnsAddress as wagmiGetEnsAddress, sendTransaction as wagmiSendTransaction, writeContract as wagmiWriteContract, waitForTransactionReceipt, watchAccount, watchConnections, watchConnectors, watchPendingTransactions } from '@wagmi/core';
import {} from '@wagmi/core/chains';
import { formatUnits, parseUnits } from 'viem';
import { normalize } from 'viem/ens';
import { AppKit, WcHelpersUtil } from '@reown/appkit';
import { ConstantsUtil as CommonConstantsUtil, NetworkUtil, isReownName } from '@reown/appkit-common';
import { CoreHelperUtil } from '@reown/appkit-core';
import { ConstantsUtil as CoreConstantsUtil } from '@reown/appkit-core';
import { CaipNetworksUtil, PresetsUtil } from '@reown/appkit-utils';
import { AdapterBlueprint } from '@reown/appkit/adapters';
import { WalletConnectConnector } from '@reown/appkit/connectors';
import { authConnector } from './connectors/AuthConnector.js';
import { walletConnect } from './connectors/UniversalConnector.js';
import { LimitterUtil } from './utils/LimitterUtil.js';
import { parseWalletCapabilities } from './utils/helpers.js';
const DEFAULT_PENDING_TRANSACTIONS_FILTER = {
    enable: false,
    pollingInterval: 30000
};
export class WagmiAdapter extends AdapterBlueprint {
    constructor(configParams) {
        super({
            projectId: configParams.projectId,
            networks: CaipNetworksUtil.extendCaipNetworks(configParams.networks, {
                projectId: configParams.projectId,
                customNetworkImageUrls: {},
                customRpcChainIds: configParams.transports
                    ? Object.keys(configParams.transports).map(Number)
                    : []
            })
        });
        this.adapterType = 'wagmi';
        this.pendingTransactionsFilter = {
            ...DEFAULT_PENDING_TRANSACTIONS_FILTER,
            ...(configParams.pendingTransactionsFilter ?? {})
        };
        this.namespace = CommonConstantsUtil.CHAIN.EVM;
        this.createConfig({
            ...configParams,
            networks: CaipNetworksUtil.extendCaipNetworks(configParams.networks, {
                projectId: configParams.projectId,
                customNetworkImageUrls: {},
                customRpcChainIds: configParams.transports
                    ? Object.keys(configParams.transports).map(Number)
                    : []
            }),
            projectId: configParams.projectId
        });
        this.setupWatchers();
    }
    async getAccounts(params) {
        const connector = this.getWagmiConnector(params.id);
        if (!connector) {
            return { accounts: [] };
        }
        if (connector.id === CommonConstantsUtil.CONNECTOR_ID.AUTH) {
            const provider = connector['provider'];
            const { address, accounts } = await provider.connect();
            return Promise.resolve({
                accounts: (accounts || [{ address, type: 'eoa' }]).map(account => CoreHelperUtil.createAccount('eip155', account.address, account.type))
            });
        }
        const { addresses, address } = getAccount(this.wagmiConfig);
        return Promise.resolve({
            accounts: (addresses || [address])?.map(val => CoreHelperUtil.createAccount('eip155', val || '', 'eoa'))
        });
    }
    getWagmiConnector(id) {
        return this.wagmiConfig.connectors.find(c => c.id === id);
    }
    createConfig(configParams) {
        this.caipNetworks = configParams.networks;
        this.wagmiChains = this.caipNetworks.filter(caipNetwork => caipNetwork.chainNamespace === CommonConstantsUtil.CHAIN.EVM);
        const transportsArr = this.wagmiChains.map(chain => [
            chain.id,
            CaipNetworksUtil.getViemTransport(chain)
        ]);
        Object.entries(configParams.transports ?? {}).forEach(([chainId, transport]) => {
            const index = transportsArr.findIndex(([id]) => id === Number(chainId));
            if (index === -1) {
                transportsArr.push([Number(chainId), transport]);
            }
            else {
                transportsArr[index] = [Number(chainId), transport];
            }
        });
        const transports = Object.fromEntries(transportsArr);
        const connectors = [...(configParams.connectors ?? [])];
        this.wagmiConfig = createConfig({
            ...configParams,
            chains: this.wagmiChains,
            transports,
            connectors
        });
    }
    setupWatchPendingTransactions() {
        if (!this.pendingTransactionsFilter.enable || this.unwatchPendingTransactions) {
            return;
        }
        this.unwatchPendingTransactions = watchPendingTransactions(this.wagmiConfig, {
            pollingInterval: this.pendingTransactionsFilter.pollingInterval,
            onError: () => { },
            onTransactions: () => {
                this.emit('pendingTransactions');
                LimitterUtil.increase('pendingTransactions');
            }
        });
        const unsubscribe = LimitterUtil.subscribeKey('pendingTransactions', val => {
            if (val >= CommonConstantsUtil.LIMITS.PENDING_TRANSACTIONS) {
                this.unwatchPendingTransactions?.();
                unsubscribe();
            }
        });
    }
    setupWatchers() {
        watchAccount(this.wagmiConfig, {
            onChange: (accountData, prevAccountData) => {
                if (accountData.status === 'disconnected' && prevAccountData.address) {
                    this.emit('disconnect');
                }
                if (accountData.status === 'connected') {
                    if (accountData.address !== prevAccountData?.address ||
                        prevAccountData.status !== 'connected') {
                        this.setupWatchPendingTransactions();
                        this.emit('accountChanged', {
                            address: accountData.address
                        });
                    }
                    if (accountData.chainId !== prevAccountData?.chainId) {
                        this.emit('switchNetwork', {
                            address: accountData.address,
                            chainId: accountData.chainId
                        });
                    }
                }
            }
        });
        watchConnections(this.wagmiConfig, {
            onChange: connections => {
                if (connections.length === 0) {
                    this.emit('disconnect');
                }
            }
        });
    }
    async addThirdPartyConnectors(options) {
        const thirdPartyConnectors = [];
        if (options.enableCoinbase !== false) {
            try {
                const { coinbaseWallet } = await import('@wagmi/connectors');
                if (coinbaseWallet) {
                    thirdPartyConnectors.push(coinbaseWallet({
                        version: '4',
                        appName: options.metadata?.name ?? 'Unknown',
                        appLogoUrl: options.metadata?.icons[0] ?? 'Unknown',
                        preference: options.coinbasePreference ?? 'all'
                    }));
                }
            }
            catch (error) {
                console.error('Failed to import Coinbase Wallet SDK:', error);
            }
        }
        thirdPartyConnectors.forEach(connector => {
            const cnctr = this.wagmiConfig._internal.connectors.setup(connector);
            this.wagmiConfig._internal.connectors.setState(prev => [...prev, cnctr]);
        });
    }
    addWagmiConnectors(options, appKit) {
        const customConnectors = [];
        if (options.enableWalletConnect !== false) {
            customConnectors.push(walletConnect(options, appKit, this.caipNetworks));
        }
        if (options.enableInjected !== false) {
            customConnectors.push(injected({ shimDisconnect: true }));
        }
        const emailEnabled = options.features?.email === undefined
            ? CoreConstantsUtil.DEFAULT_FEATURES.email
            : options.features?.email;
        const socialsEnabled = options.features?.socials
            ? options.features?.socials?.length > 0
            : CoreConstantsUtil.DEFAULT_FEATURES.socials;
        if (emailEnabled || socialsEnabled) {
            customConnectors.push(authConnector({
                chains: this.wagmiChains,
                options: { projectId: options.projectId, enableAuthLogger: options.enableAuthLogger }
            }));
        }
        customConnectors.forEach(connector => {
            const cnctr = this.wagmiConfig._internal.connectors.setup(connector);
            this.wagmiConfig._internal.connectors.setState(prev => [...prev, cnctr]);
        });
    }
    async signMessage(params) {
        try {
            const signature = await signMessage(this.wagmiConfig, {
                message: params.message,
                account: params.address
            });
            return { signature };
        }
        catch (error) {
            throw new Error('WagmiAdapter:signMessage - Sign message failed');
        }
    }
    async sendTransaction(params) {
        const { chainId } = getAccount(this.wagmiConfig);
        const txParams = {
            account: params.address,
            to: params.to,
            value: params.value,
            gas: params.gas,
            gasPrice: params.gasPrice,
            data: params.data,
            chainId,
            type: 'legacy'
        };
        await prepareTransactionRequest(this.wagmiConfig, txParams);
        const tx = await wagmiSendTransaction(this.wagmiConfig, txParams);
        await waitForTransactionReceipt(this.wagmiConfig, { hash: tx, timeout: 25000 });
        return { hash: tx };
    }
    async writeContract(params) {
        const { caipNetwork, ...data } = params;
        const chainId = Number(NetworkUtil.caipNetworkIdToNumber(caipNetwork.caipNetworkId));
        const tx = await wagmiWriteContract(this.wagmiConfig, {
            chain: this.wagmiChains?.[chainId],
            chainId,
            address: data.tokenAddress,
            account: data.fromAddress,
            abi: data.abi,
            functionName: data.method,
            args: data.args
        });
        return { hash: tx };
    }
    async getEnsAddress(params) {
        const { name, caipNetwork } = params;
        try {
            if (!this.wagmiConfig) {
                throw new Error('networkControllerClient:getApprovedCaipNetworksData - wagmiConfig is undefined');
            }
            let ensName = false;
            let wcName = false;
            if (isReownName(name)) {
                wcName = (await WcHelpersUtil.resolveReownName(name)) || false;
            }
            if (caipNetwork.id === 1) {
                ensName = await wagmiGetEnsAddress(this.wagmiConfig, {
                    name: normalize(name),
                    chainId: caipNetwork.id
                });
            }
            return { address: ensName || wcName || false };
        }
        catch {
            return { address: false };
        }
    }
    async estimateGas(params) {
        try {
            const result = await wagmiEstimateGas(this.wagmiConfig, {
                account: params.address,
                to: params.to,
                data: params.data,
                type: 'legacy'
            });
            return { gas: result };
        }
        catch (error) {
            throw new Error('WagmiAdapter:estimateGas - error estimating gas');
        }
    }
    parseUnits(params) {
        return parseUnits(params.value, params.decimals);
    }
    formatUnits(params) {
        return formatUnits(params.value, params.decimals);
    }
    async addWagmiConnector(connector, options) {
        if (connector.id === CommonConstantsUtil.CONNECTOR_ID.AUTH ||
            connector.id === CommonConstantsUtil.CONNECTOR_ID.WALLET_CONNECT) {
            return;
        }
        const provider = (await connector.getProvider().catch(() => undefined));
        this.addConnector({
            id: connector.id,
            explorerId: PresetsUtil.ConnectorExplorerIds[connector.id],
            imageUrl: options?.connectorImages?.[connector.id] ?? connector.icon,
            name: PresetsUtil.ConnectorNamesMap[connector.id] ?? connector.name,
            imageId: PresetsUtil.ConnectorImageIds[connector.id],
            type: PresetsUtil.ConnectorTypesMap[connector.type] ?? 'EXTERNAL',
            info: connector.id === CommonConstantsUtil.CONNECTOR_ID.INJECTED
                ? undefined
                : { rdns: connector.id },
            provider,
            chain: this.namespace,
            chains: []
        });
    }
    async syncConnectors(options, appKit) {
        watchConnectors(this.wagmiConfig, {
            onChange: connectors => connectors.forEach(connector => this.addWagmiConnector(connector, options))
        });
        await Promise.all(this.wagmiConfig.connectors.map(connector => this.addWagmiConnector(connector, options)));
        this.addWagmiConnectors(options, appKit);
        await this.addThirdPartyConnectors(options);
    }
    async syncConnection(params) {
        const { id } = params;
        const connections = getConnections(this.wagmiConfig);
        const connection = connections.find(c => c.connector.id === id);
        const connector = this.getWagmiConnector(id);
        const provider = (await connector?.getProvider());
        return {
            chainId: Number(connection?.chainId),
            address: connection?.accounts[0],
            provider,
            type: connection?.connector.type,
            id: connection?.connector.id
        };
    }
    async connectWalletConnect(chainId) {
        const walletConnectConnector = this.getWalletConnectConnector();
        const isAuthenticated = await walletConnectConnector.authenticate();
        if (isAuthenticated) {
            return { clientId: await walletConnectConnector.provider.client.core.crypto.getClientId() };
        }
        const wagmiConnector = this.getWagmiConnector('walletConnect');
        if (!wagmiConnector) {
            throw new Error('UniversalAdapter:connectWalletConnect - connector not found');
        }
        await connect(this.wagmiConfig, {
            connector: wagmiConnector,
            chainId: chainId ? Number(chainId) : undefined
        });
        return { clientId: await walletConnectConnector.provider.client.core.crypto.getClientId() };
    }
    async connect(params) {
        const { id, provider, type, info, chainId } = params;
        const connector = this.getWagmiConnector(id);
        if (!connector) {
            throw new Error('connectionControllerClient:connectExternal - connector is undefined');
        }
        if (provider && info && connector.id === CommonConstantsUtil.CONNECTOR_ID.EIP6963) {
            connector.setEip6963Wallet?.({ provider, info });
        }
        const res = await connect(this.wagmiConfig, {
            connector,
            chainId: chainId ? Number(chainId) : undefined
        });
        return {
            address: res.accounts[0],
            chainId: res.chainId,
            provider: provider,
            type: type,
            id
        };
    }
    async reconnect(params) {
        const { id } = params;
        const connector = this.getWagmiConnector(id);
        if (!connector) {
            throw new Error('connectionControllerClient:connectExternal - connector is undefined');
        }
        await reconnect(this.wagmiConfig, {
            connectors: [connector]
        });
    }
    async getBalance(params) {
        const caipNetwork = this.caipNetworks?.find(network => network.id === params.chainId);
        if (caipNetwork && this.wagmiConfig) {
            const chainId = Number(params.chainId);
            const balance = await getBalance(this.wagmiConfig, {
                address: params.address,
                chainId,
                token: params.tokens?.[caipNetwork.caipNetworkId]?.address
            });
            return { balance: balance.formatted, symbol: balance.symbol };
        }
        return { balance: '', symbol: '' };
    }
    async getProfile(params) {
        const chainId = params.chainId;
        const profileName = await getEnsName(this.wagmiConfig, {
            address: params.address,
            chainId
        });
        if (profileName) {
            const profileImage = await getEnsAvatar(this.wagmiConfig, {
                name: profileName,
                chainId
            });
            return { profileName, profileImage: profileImage ?? undefined };
        }
        return { profileName: undefined, profileImage: undefined };
    }
    getWalletConnectProvider() {
        return this.getWagmiConnector('walletConnect')?.['provider'];
    }
    async disconnect() {
        const connections = getConnections(this.wagmiConfig);
        await Promise.all(connections.map(async (connection) => {
            const connector = this.getWagmiConnector(connection.connector.id);
            if (connector) {
                await wagmiDisconnect(this.wagmiConfig, { connector });
            }
        }));
    }
    async switchNetwork(params) {
        await switchChain(this.wagmiConfig, { chainId: params.caipNetwork.id });
    }
    async getCapabilities(params) {
        if (!this.wagmiConfig) {
            throw new Error('connectionControllerClient:getCapabilities - wagmiConfig is undefined');
        }
        const connections = getConnections(this.wagmiConfig);
        const connection = connections[0];
        const connector = connection ? this.getWagmiConnector(connection.connector.id) : null;
        if (!connector) {
            throw new Error('connectionControllerClient:getCapabilities - connector is undefined');
        }
        const provider = (await connector.getProvider());
        if (!provider) {
            throw new Error('connectionControllerClient:getCapabilities - provider is undefined');
        }
        const walletCapabilitiesString = provider.session?.sessionProperties?.['capabilities'];
        if (walletCapabilitiesString) {
            const walletCapabilities = parseWalletCapabilities(walletCapabilitiesString);
            const accountCapabilities = walletCapabilities[params];
            if (accountCapabilities) {
                return accountCapabilities;
            }
        }
        return await provider.request({ method: 'wallet_getCapabilities', params: [params] });
    }
    async grantPermissions(params) {
        if (!this.wagmiConfig) {
            throw new Error('connectionControllerClient:grantPermissions - wagmiConfig is undefined');
        }
        const connections = getConnections(this.wagmiConfig);
        const connection = connections[0];
        const connector = connection ? this.getWagmiConnector(connection.connector.id) : null;
        if (!connector) {
            throw new Error('connectionControllerClient:grantPermissions - connector is undefined');
        }
        const provider = (await connector.getProvider());
        if (!provider) {
            throw new Error('connectionControllerClient:grantPermissions - provider is undefined');
        }
        return provider.request({ method: 'wallet_grantPermissions', params });
    }
    async revokePermissions(params) {
        if (!this.wagmiConfig) {
            throw new Error('connectionControllerClient:revokePermissions - wagmiConfig is undefined');
        }
        const connections = getConnections(this.wagmiConfig);
        const connection = connections[0];
        const connector = connection ? this.getWagmiConnector(connection.connector.id) : null;
        if (!connector) {
            throw new Error('connectionControllerClient:revokePermissions - connector is undefined');
        }
        const provider = (await connector.getProvider());
        if (!provider) {
            throw new Error('connectionControllerClient:revokePermissions - provider is undefined');
        }
        return provider.request({ method: 'wallet_revokePermissions', params });
    }
    setUniversalProvider(universalProvider) {
        this.addConnector(new WalletConnectConnector({
            provider: universalProvider,
            caipNetworks: this.caipNetworks || [],
            namespace: 'eip155'
        }));
    }
}
//# sourceMappingURL=client.js.map